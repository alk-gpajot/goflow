package gfgo

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"text/template"

	"github.com/alkemics/goflow"
)

// The nodeSorter sorts the node in alphabetical order, to make the graph generation
// reproducible.
type nodeSorter struct {
	goflow.GraphRenderer
}

func (pp nodeSorter) Nodes() []goflow.NodeRenderer {
	nodes := pp.GraphRenderer.Nodes()
	sorted := make([]goflow.NodeRenderer, len(nodes))
	copy(sorted, nodes)

	sort.SliceStable(sorted, func(i, j int) bool {
		return sorted[i].ID() <= sorted[j].ID()
	})

	return sorted
}

// Generate writes the graph g in w.
//
// It does not format the code, for example in the case of imports
// added twice. Use Writer to do so.
func Generate(w io.Writer, g goflow.GraphRenderer) error {
	tmpl, err := template.
		New("template").
		Funcs(template.FuncMap{
			"DepsNameAndTypes": func(fields []goflow.Field) string {
				s := make([]string, len(fields))
				for i, f := range fields {
					s[i] = fmt.Sprintf("%s %s", f.Name, f.Type)
				}
				return strings.Join(s, "\n")
			},
			"NameAndTypes": func(fields []goflow.Field) string {
				s := make([]string, len(fields))
				for i, f := range fields {
					s[i] = fmt.Sprintf("%s %s", f.Name, f.Type)
				}
				return strings.Join(s, ", ")
			},
			"Names": func(fields []goflow.Field) string {
				s := make([]string, len(fields))
				for i, f := range fields {
					s[i] = f.Name
				}
				return strings.Join(s, ", ")
			},
		}).
		Parse(tmplStr)
	if err != nil {
		return err
	}

	return tmpl.Execute(w, nodeSorter{g})
}

// tmplStr defines the template used to generate a graph. It is a go constant
// and not a file to be easier to ship when extending the generator.
const tmplStr = `
// Code generated by goflow DO NOT EDIT.

//go:build !codeanalysis

package {{ .Pkg }}

import (
    {{ range .Imports -}}
    {{ .Pkg }} "{{ .Dir }}"
    {{ end }}
)

/*
{{ .Doc }}
*/
type {{ .Name }} struct {
	{{- DepsNameAndTypes .Dependencies -}}
}

func New{{ .Name }}({{ NameAndTypes .Dependencies }}) {{ .Name }} {
	return {{ .Name }}{
		{{ range .Dependencies -}}
		{{ .Name }}: {{ .Name }},
		{{- end }}
	}
}

func new{{ .Name }}(id string, {{ NameAndTypes .Dependencies }}) {{ .Name }} {
    return {{ .Name }}{
        {{ range .Dependencies -}}
        {{ .Name }}: {{ .Name }},
        {{- end }}
    }
}

/*
{{ .Doc }}
*/
func (g *{{ .Name }}) Run({{ NameAndTypes .Inputs }}) ({{ NameAndTypes .Outputs }}) {
    {{ range .Nodes }}
    {{ $id := .ID }}
    // {{ $id }} outputs
    {{ range .Outputs -}}
    var {{ .Name }} {{ .Type }}
    {{ end }}
    {{ end }}

	igniteNodeID := "ignite"
	doneNodeID := "done"

	done := make(chan string)
	defer close(done)

	steps := map[string]struct {
		deps map[string]struct{}
		run  func()
		alreadyDone bool
	}{
		{{ range .Nodes }}
		"{{ .ID }}": {
		    deps: map[string]struct{}{
		        {{ range .Previous -}}
		        "{{ . }}": {},
		        {{ end -}}
		        igniteNodeID: {},
		    },
		    run: func() {
                {{ .Run (.Inputs) (.Outputs) }}
		        done <- "{{ .ID }}"
		    },
		    alreadyDone: false,
		},
		{{- end }}
		igniteNodeID: {
		    deps: map[string]struct{}{},
		    run: func() {
                done <- igniteNodeID
		    },
            alreadyDone: false,
		},
		doneNodeID: {
		    deps: map[string]struct{}{
                {{ range .Nodes -}}
                "{{ .ID }}": {},
                {{ end -}}
		    },
		    run: func() {
                done <- doneNodeID
		    },
            alreadyDone: false,
		},
	}

	// Ignite
	ignite := steps[igniteNodeID]
	ignite.alreadyDone = true
	steps[igniteNodeID] = ignite
	go steps[igniteNodeID].run()

	// Resolve the graph
	for resolved := range done {
		if resolved == doneNodeID {
			// If all the graph was resolved, get out of the loop
			break
		}

		for name, step := range steps {
			delete(step.deps, resolved)
			if len(step.deps) == 0 && !step.alreadyDone {
				step.alreadyDone = true
				steps[name] = step
				go step.run()
			}
		}
	}

	return {{ Names .Outputs }}
}
`
