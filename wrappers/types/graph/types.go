// Code generated by goflow DO NOT EDIT.

//go:build !codeanalysis

package main

import (
	"context"

	"github.com/alkemics/goflow/example/constants/functions"
	"github.com/alkemics/goflow/example/constants/numbers"
	"github.com/alkemics/goflow/example/nodes"
)

/*
optional: no
*/
type Types struct{}

func NewTypes() Types {
	return Types{}
}

func newTypes(id string) Types {
	return Types{}
}

/*
optional: no
*/
func (g *Types) Run(ctx context.Context, a uint, b []uint, c uint, no bool) (add uint, add_10 uint, forwardedInputs []uint) {
	// __add_10_a outputs
	var __add_10_a_aggregated uint

	// __add_10_b outputs
	var __add_10_b_aggregated uint

	// __add_list outputs
	var __add_list_aggregated []uint

	// __add_reducer outputs
	var __add_reducer_aggregated functions.UIntReducer

	// __ctx outputs
	var __ctx_ctx context.Context

	// __do_not_print_values outputs
	var __do_not_print_values_aggregated []interface{}

	// __output_add_10_builder outputs
	var __output_add_10_builder_add_10 uint

	// __output_add_builder outputs
	var __output_add_builder_add uint

	// __output_forwardedInputs_builder outputs
	var __output_forwardedInputs_builder_forwardedInputs []uint

	// __print_pi_values outputs
	var __print_pi_values_aggregated []interface{}

	// __print_values outputs
	var __print_values_aggregated []interface{}

	// add outputs
	var add_result uint

	// add_10 outputs
	var add_10_sum uint

	// do_not_print outputs

	// inputs outputs
	var inputs_a uint
	var inputs_b []uint
	var inputs_c uint
	var inputs_no bool

	// make_slice outputs
	var make_slice_list []uint

	// print outputs

	// print_pi outputs

	igniteNodeID := "ignite"
	doneNodeID := "done"

	done := make(chan string)
	defer close(done)

	steps := map[string]struct {
		deps        map[string]struct{}
		run         func()
		alreadyDone bool
	}{
		"__add_10_a": {
			deps: map[string]struct{}{
				"inputs":     {},
				igniteNodeID: {},
			},
			run: func() {
				__add_10_a_aggregated = inputs_a
				done <- "__add_10_a"
			},
			alreadyDone: false,
		},
		"__add_10_b": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				__add_10_b_aggregated = 10
				done <- "__add_10_b"
			},
			alreadyDone: false,
		},
		"__add_list": {
			deps: map[string]struct{}{
				"inputs":     {},
				"add_10":     {},
				"make_slice": {},
				igniteNodeID: {},
			},
			run: func() {
				__add_list_aggregated = append(__add_list_aggregated, inputs_a)
				__add_list_aggregated = append(__add_list_aggregated, inputs_b...)
				__add_list_aggregated = append(__add_list_aggregated, inputs_c)
				__add_list_aggregated = append(__add_list_aggregated, add_10_sum)
				__add_list_aggregated = append(__add_list_aggregated, make_slice_list...)
				__add_list_aggregated = append(__add_list_aggregated, numbers.One)
				done <- "__add_list"
			},
			alreadyDone: false,
		},
		"__add_reducer": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				__add_reducer_aggregated = functions.UIntSum
				done <- "__add_reducer"
			},
			alreadyDone: false,
		},
		"__ctx": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				__ctx_ctx = ctx
				done <- "__ctx"
			},
			alreadyDone: false,
		},
		"__do_not_print_values": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				__do_not_print_values_aggregated = append(__do_not_print_values_aggregated, "this is not printed")
				done <- "__do_not_print_values"
			},
			alreadyDone: false,
		},
		"__output_add_10_builder": {
			deps: map[string]struct{}{
				"add_10":     {},
				igniteNodeID: {},
			},
			run: func() {
				__output_add_10_builder_add_10 = add_10_sum
				add_10 = __output_add_10_builder_add_10
				done <- "__output_add_10_builder"
			},
			alreadyDone: false,
		},
		"__output_add_builder": {
			deps: map[string]struct{}{
				"add":        {},
				igniteNodeID: {},
			},
			run: func() {
				__output_add_builder_add = add_result
				add = __output_add_builder_add
				done <- "__output_add_builder"
			},
			alreadyDone: false,
		},
		"__output_forwardedInputs_builder": {
			deps: map[string]struct{}{
				"inputs":     {},
				igniteNodeID: {},
			},
			run: func() {
				__output_forwardedInputs_builder_forwardedInputs = append(__output_forwardedInputs_builder_forwardedInputs, inputs_a)
				__output_forwardedInputs_builder_forwardedInputs = append(__output_forwardedInputs_builder_forwardedInputs, inputs_b...)
				__output_forwardedInputs_builder_forwardedInputs = append(__output_forwardedInputs_builder_forwardedInputs, inputs_c)
				forwardedInputs = __output_forwardedInputs_builder_forwardedInputs
				done <- "__output_forwardedInputs_builder"
			},
			alreadyDone: false,
		},
		"__print_pi_values": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				__print_pi_values_aggregated = append(__print_pi_values_aggregated, "Pi:")
				__print_pi_values_aggregated = append(__print_pi_values_aggregated, numbers.Pi)
				done <- "__print_pi_values"
			},
			alreadyDone: false,
		},
		"__print_values": {
			deps: map[string]struct{}{
				"add":        {},
				igniteNodeID: {},
			},
			run: func() {
				__print_values_aggregated = append(__print_values_aggregated, "the result should be 28")
				__print_values_aggregated = append(__print_values_aggregated, add_result)
				done <- "__print_values"
			},
			alreadyDone: false,
		},
		"add": {
			deps: map[string]struct{}{
				"__add_list":    {},
				"__add_reducer": {},
				igniteNodeID:    {},
			},
			run: func() {
				add_result = nodes.UIntAggregator(__add_list_aggregated, __add_reducer_aggregated)
				done <- "add"
			},
			alreadyDone: false,
		},
		"add_10": {
			deps: map[string]struct{}{
				"__add_10_a": {},
				"__add_10_b": {},
				igniteNodeID: {},
			},
			run: func() {
				add_10_sum = nodes.UAdd(__add_10_a_aggregated, __add_10_b_aggregated)
				done <- "add_10"
			},
			alreadyDone: false,
		},
		"do_not_print": {
			deps: map[string]struct{}{
				"__do_not_print_values": {},
				"inputs":                {},
				igniteNodeID:            {},
			},
			run: func() {
				if inputs_no {
					nodes.Printer(__do_not_print_values_aggregated)
				}

				done <- "do_not_print"
			},
			alreadyDone: false,
		},
		"inputs": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				inputs_a = a
				inputs_b = b
				inputs_c = c
				inputs_no = no
				done <- "inputs"
			},
			alreadyDone: false,
		},
		"make_slice": {
			deps: map[string]struct{}{
				igniteNodeID: {},
			},
			run: func() {
				make_slice_list = nodes.UIntSliceMaker()
				done <- "make_slice"
			},
			alreadyDone: false,
		},
		"print": {
			deps: map[string]struct{}{
				"__ctx":          {},
				"__print_values": {},
				igniteNodeID:     {},
			},
			run: func() {
				nodes.PrinterCtx(__ctx_ctx, __print_values_aggregated)
				done <- "print"
			},
			alreadyDone: false,
		},
		"print_pi": {
			deps: map[string]struct{}{
				"__print_pi_values": {},
				igniteNodeID:        {},
			},
			run: func() {
				nodes.Printer(__print_pi_values_aggregated)
				done <- "print_pi"
			},
			alreadyDone: false,
		},
		igniteNodeID: {
			deps: map[string]struct{}{},
			run: func() {
				done <- igniteNodeID
			},
			alreadyDone: false,
		},
		doneNodeID: {
			deps: map[string]struct{}{
				"__add_10_a":                       {},
				"__add_10_b":                       {},
				"__add_list":                       {},
				"__add_reducer":                    {},
				"__ctx":                            {},
				"__do_not_print_values":            {},
				"__output_add_10_builder":          {},
				"__output_add_builder":             {},
				"__output_forwardedInputs_builder": {},
				"__print_pi_values":                {},
				"__print_values":                   {},
				"add":                              {},
				"add_10":                           {},
				"do_not_print":                     {},
				"inputs":                           {},
				"make_slice":                       {},
				"print":                            {},
				"print_pi":                         {},
			},
			run: func() {
				done <- doneNodeID
			},
			alreadyDone: false,
		},
	}

	// Ignite
	ignite := steps[igniteNodeID]
	ignite.alreadyDone = true
	steps[igniteNodeID] = ignite
	go steps[igniteNodeID].run()

	// Resolve the graph
	for resolved := range done {
		if resolved == doneNodeID {
			// If all the graph was resolved, get out of the loop
			break
		}

		for name, step := range steps {
			delete(step.deps, resolved)
			if len(step.deps) == 0 && !step.alreadyDone {
				step.alreadyDone = true
				steps[name] = step
				go step.run()
			}
		}
	}

	return add, add_10, forwardedInputs
}
